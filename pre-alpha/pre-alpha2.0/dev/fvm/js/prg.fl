(
prg
===

This is an unstable Freelang program being used for iterative experimentation
in the development of the JavaScript prototype of the FVM 2.0.

It can be compiled by...

  ./mk.sh prg.fl

...to produce 'prgBase64.js' for use by 'fvmui.html'.

Copyright Â© 2017, Robert Gollagher.
SPDX-License-Identifier: GPL-3.0+

Program:    prg.fl
Author :    Robert Gollagher   robert.gollagher@freeputer.net
Created:    20170513
Updated:    20170514-2337+
Version:    unstable

===========================================================================

WARNING: This is pre-alpha software and as such may well be incomplete,
unstable and unreliable. It is considered to be suitable only for
experimentation and nothing more.

===========================================================================

NOTES

Syntax for compiler directive which declares the current failure address
for branch on failure is simply to surround the failure address
with <> as follows. This is entirely compile-time logic:

  <:bad>          \ a back-reference to a previous label
  <1024>          \ a literal PRG cell number
  <:>              \ revert to previous failure address

The default is <0> if no failure address is ever declared. This could
potentially cause a faulty program to endlessly restart itself, so it is
wise to always declare a sensible failure address. A failure-address
declaration applies until the compiler encounters another such
declaration. This is compile-time logic not runtime logic.

All other compiler directives in future shall be surrounded by <<>> and
there is currently only one of these, namely slotFloor:

  <<slotFloor>>   \ formerly was simply slotFloor rather than <<slotFloor>>

=========================================================================== )
<2> <<slotFloor>> 16777216 INT_MAX. 2147483647 FAIL. 1 OK. 0

prg{

  go :entryPoint fail entryPoint: runB halt

  \ Correct but not robust
  : run
    {..INT_MAX}
  \ 3
    add5
    add5
  ;

  \ Robust and correct (will be when add stack guards)
  : runA
    {..INT_MAX}
  \ 3
    add5A go!=0 :calcFail
    add5A go!=0 :calcFail
    calcDone:
      {..OK} ret
    calcFail:
      0 {..FAIL}
  ;

  \ Robust and correct (will be when add stack guards)
  : runB
    {..INT_MAX}
  \ 3
    5 add go!=0 :calcFail
    5 add go!=0 :calcFail
    calcDone:
      {..OK} ret
    calcFail:
      {..FAIL}
  ;

  \ Correct but not robust
  : add5 5 + ;

  \ Robust and correct (will be when add stack guards)
  : add5A ( n -- n+5 OK/FAIL )
    go :try fail: {..FAIL} ret
    try:
      5
      <:fail>
        +
      <:>
        {..OK}
  ;

  \ Robust and correct (will be when add stack guards)
  : add ( n1 n2 -- n1+n2 OK/FAIL )
    go :try fail: 0 {..FAIL} ret
    try:
      <:fail>
        +
      <:>
        {..OK}
  ;

}prg

