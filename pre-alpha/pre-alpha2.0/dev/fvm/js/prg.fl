(
prg
===

This is an unstable Freelang program being used for iterative experimentation
in the development of the JavaScript prototype of the FVM 2.0.

It can be compiled by...

  ./mk.sh prg.fl

...to produce 'prgBase64.js' for use by 'fvmui.html'.

Copyright Â© 2017, Robert Gollagher.
SPDX-License-Identifier: GPL-3.0+

Program:    prg.fl
Author :    Robert Gollagher   robert.gollagher@freeputer.net
Created:    20170513
Updated:    20170521-1216+
Version:    unstable

===========================================================================

WARNING: This is pre-alpha software and as such may well be incomplete,
unstable and unreliable. It is considered to be suitable only for
experimentation and nothing more.

===========================================================================

NOTES

Syntax for compiler directive which declares the current failure address
for branch on failure is simply to surround the failure address
with <> as follows. This is entirely compile-time logic:

  <:bad>          \ a back-reference to a previous label
  <1024>          \ a literal PRG cell number
  <:>              \ revert to previous failure address

The default is <0> if no failure address is ever declared. This could
potentially cause a faulty program to endlessly restart itself, so it is
wise to always declare a sensible failure address. A failure-address
declaration applies until the compiler encounters another such
declaration. This is compile-time logic not runtime logic.

All other compiler directives in future shall be surrounded by <<>> and
there is currently only one of these, namely slotFloor:

  <<slotFloor>>   \ formerly was simply slotFloor rather than <<slotFloor>>

=========================================================================== )
<<slotFloor>> 16777216 INT_MAX. 2147483647 NIM. -2147483648 ERR. 1 OK. 0

( TODO: Consider:
  - Is there any merit in going to constant width for all instructions?
    That is, possibly to simplify compiler design.
    Also to prevent alignment issues.
)

<2> go :run fail

    run:
      prg{run} halt

prg{

  : run calc ;
  : calc ;

(((
  fail: fail <:fail>
  illeg: fail
  fret: fret
  fret_risk: risk fret
  fret1: drop fret
  fret2: drop drop fret
  fret3: drop drop drop fret
  fret4: drop drop drop drop fret

  <:fret> : run calc ;
  <:fret> : calc ( 3 ) {..INT_MAX} 5 + ;
  <:fret_risk> : add + ;
  <:fret> : add1 1 + ;
  <:fret> : add2 2 + ;
  
  \ fvm2.js is currently hardcoded to cause the below to fail
  : foo <::fret> 1 <::fret1> 2 <::fret2> 3 <::fret3> 4 <::fret4> 5 ;
)))

}prg

