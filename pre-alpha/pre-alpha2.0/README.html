<p><meta http-equiv="content-type" content="text/html;charset=utf-8"></p>
<h1 id="freeputer2.0">Freeputer 2.0</h1>
<p>Freeputer ( ) [ ] { } smaller simpler better</p>
<h2 id="values">Values</h2>
<ol style="list-style-type: decimal">
<li>VM <strong>simpler and easier to implement</strong>.</li>
<li>VM <strong>even more portable</strong>.</li>
<li>VM <strong>entirely correct</strong>.</li>
<li>VM <strong>standardized</strong>.</li>
<li>VM <strong>smaller</strong>.</li>
<li>VM <strong>faster</strong>.</li>
</ol>
<h2 id="discussion">Discussion</h2>
<p>Although Freeputer 2.0 will not run unmodified Freeputer 1.0 programs, the fundamental design remains similar: a stack machine which is easy for human beings to understand and which favours correctness over robustness. The architecture enforces correctness by trapping. Robustness is the responsibility of the programmer and can be aided by self-virtualization of virtual machine instances.</p>
<p>Freeputer 2.0 will be implemented in JavaScript, which for the first time should make it easy to run Freeputer in popular web browsers available on billions of consumer devices. Furthermore, Freeputer 2.0 will continue to support targeting x86, C, Linux, and Java. There will also be new bare-metal support for targeting Arduino (ARM) and chipKIT (PIC32) boards via the Arduino IDE. So the same small Freeputer program could run on a powerful server or in a web browser or on a microcontroller. This is true software reuse.</p>
<h3 id="proposed-design">Proposed Design</h3>
<p>Experiments are in progress to radically simplify the design (see 'fvm2.js' and 'prg.js').</p>
<p>Therefore the most recently proposed design, shown below, is no longer current.</p>
<ul>
<li>Stack machine with 4 stacks: data (ds), temporary (ts), return (rs), counter (cs).</li>
<li>Harvard architecture ensures ease of native implementation:
<ul>
<li>program logic is entirely independent of instruction encoding;</li>
<li>program memory (pm) &lt;= 2^24 <em>instructions</em> (as reported by the pmi instruction);</li>
<li>data memory (dm) &lt;= 2^30 <em>words</em> (as reported by the dmw instruction).</li>
</ul></li>
<li>Words and stack elements are 32-bit and arithmetic is two's complement.</li>
<li>Non-native implementations use fixed-width 32-bit instructions (FW32):
<ul>
<li>literals 1:31 (bit 31 <em>literal bit</em>, 30..0 <em>literal value</em>);</li>
<li>other 8:24 (bits 31..24 <em>opcode</em>, 23..0 <em>instruction number</em>, <em>metadata</em>, or unused).</li>
</ul></li>
<li>The VM traps to fail fast and finally. This includes:
<ul>
<li>arithmetic traps (from add, sub, inc, dec, mul, div, mod); and</li>
<li>all other traps as seen in FVM 1.0; but</li>
<li>without any reset capability.</li>
</ul></li>
<li>However, it is possible to achieve robustness using:
<ul>
<li>the catch instruction which:
<ul>
<li>branches if the previously executed instruction trapped;</li>
<li>otherwise functions as a no-op.</li>
</ul></li>
<li>several convenient metadata instructions which:
<ul>
<li>make it easy to conditionally branch if prerequisites are not met;</li>
<li>include the pmi, dmw, dsa, dse, tsa, tse, rsa, rse, csa and cse instructions.</li>
</ul></li>
</ul></li>
<li>The instruction set will include:
<ul>
<li>significantly fewer instructions than FVM 1.0;</li>
<li>no instructions prematurely optimizing performance;</li>
<li>a sufficiently large set of convenient RISC instructions;</li>
<li>no CISC instructions (instead there will be RISC instructions plus rpt);</li>
<li>the instructions: halt, fail.</li>
</ul></li>
<li>The I/O strategy is profoundly simple:
<ul>
<li>the only I/O instructions are in, out; and</li>
<li>these branch on failure but usually succeed; and</li>
<li>they simply move 1 word to/from the data stack; and</li>
<li>there is only 1 input stream (stdin) for the in instruction; and</li>
<li>there is only 1 output stream (stdout) for the out instruction; and</li>
<li>it is the responsibility of the <em>environ</em> to make these streams intelligent; and</li>
<li>there is no limit to how intelligent an <em>environ</em> and these streams can be; and</li>
<li>the protocol an <em>environ</em> uses is explicit in a program written for it; and</li>
<li>correct outcomes require deployment to an appropriate <em>environ</em>.</li>
</ul></li>
<li>The design might possibly include a ground state such as:
<ul>
<li>a REPL fallback after a trap ends execution; or</li>
<li>a hypervisor.</li>
</ul></li>
<li>Support for tracing is optional.</li>
</ul>
<hr />
<p>Copyright © Robert Gollagher 2017, 2018</p>
<p>This document was written by Robert Gollagher.<br />
This document was created on 3 March 2017.<br />
This document was last updated on 11 April 2018 at 00:48<br />
This document is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="doc/img/80x15.png" /></a></p>
<p>The official Freeputer website is <a href="http://www.freeputer.net">freeputer.net</a>.<br />
Robert Gollagher may be reached at</p>
<div class="figure">
<img src="doc/img/abc.png" />

</div>
<hr />
